{"ast":null,"code":"function getNextIndex({\n  direction,\n  levelIndex,\n  rowIndex,\n  cellIndex,\n  size\n}) {\n  switch (direction) {\n    case \"up\":\n      if (levelIndex === 0 && rowIndex === 0) {\n        return null;\n      }\n      if (rowIndex === 0) {\n        return {\n          levelIndex: levelIndex - 1,\n          rowIndex: cellIndex <= size[levelIndex - 1][size[levelIndex - 1].length - 1] - 1 ? size[levelIndex - 1].length - 1 : size[levelIndex - 1].length - 2,\n          cellIndex\n        };\n      }\n      return {\n        levelIndex,\n        rowIndex: rowIndex - 1,\n        cellIndex\n      };\n    case \"down\":\n      if (rowIndex === size[levelIndex].length - 1) {\n        return {\n          levelIndex: levelIndex + 1,\n          rowIndex: 0,\n          cellIndex\n        };\n      }\n      if (rowIndex === size[levelIndex].length - 2 && cellIndex >= size[levelIndex][size[levelIndex].length - 1]) {\n        return {\n          levelIndex: levelIndex + 1,\n          rowIndex: 0,\n          cellIndex\n        };\n      }\n      return {\n        levelIndex,\n        rowIndex: rowIndex + 1,\n        cellIndex\n      };\n    case \"left\":\n      if (levelIndex === 0 && rowIndex === 0 && cellIndex === 0) {\n        return null;\n      }\n      if (rowIndex === 0 && cellIndex === 0) {\n        return {\n          levelIndex: levelIndex - 1,\n          rowIndex: size[levelIndex - 1].length - 1,\n          cellIndex: size[levelIndex - 1][size[levelIndex - 1].length - 1] - 1\n        };\n      }\n      if (cellIndex === 0) {\n        return {\n          levelIndex,\n          rowIndex: rowIndex - 1,\n          cellIndex: size[levelIndex][rowIndex - 1] - 1\n        };\n      }\n      return {\n        levelIndex,\n        rowIndex,\n        cellIndex: cellIndex - 1\n      };\n    case \"right\":\n      if (rowIndex === size[levelIndex].length - 1 && cellIndex === size[levelIndex][rowIndex] - 1) {\n        return {\n          levelIndex: levelIndex + 1,\n          rowIndex: 0,\n          cellIndex: 0\n        };\n      }\n      if (cellIndex === size[levelIndex][rowIndex] - 1) {\n        return {\n          levelIndex,\n          rowIndex: rowIndex + 1,\n          cellIndex: 0\n        };\n      }\n      return {\n        levelIndex,\n        rowIndex,\n        cellIndex: cellIndex + 1\n      };\n    default:\n      return {\n        levelIndex,\n        rowIndex,\n        cellIndex\n      };\n  }\n}\nfunction focusOnNextFocusableControl({\n  controlsRef,\n  direction,\n  levelIndex,\n  rowIndex,\n  cellIndex,\n  size\n}) {\n  var _a, _b;\n  const nextIndex = getNextIndex({\n    direction,\n    size,\n    rowIndex,\n    cellIndex,\n    levelIndex\n  });\n  if (!nextIndex) {\n    return;\n  }\n  const controlToFocus = (_b = (_a = controlsRef.current[nextIndex.levelIndex]) == null ? void 0 : _a[nextIndex.rowIndex]) == null ? void 0 : _b[nextIndex.cellIndex];\n  if (!controlToFocus) {\n    return;\n  }\n  if (controlToFocus.disabled || controlToFocus.getAttribute(\"data-hidden\") || controlToFocus.getAttribute(\"data-outside\")) {\n    focusOnNextFocusableControl({\n      controlsRef,\n      direction,\n      levelIndex: nextIndex.levelIndex,\n      cellIndex: nextIndex.cellIndex,\n      rowIndex: nextIndex.rowIndex,\n      size\n    });\n  } else {\n    controlToFocus.focus();\n  }\n}\nfunction getDirection(key) {\n  switch (key) {\n    case \"ArrowDown\":\n      return \"down\";\n    case \"ArrowUp\":\n      return \"up\";\n    case \"ArrowRight\":\n      return \"right\";\n    case \"ArrowLeft\":\n      return \"left\";\n    default:\n      return null;\n  }\n}\nfunction getControlsSize(controlsRef) {\n  return controlsRef.current.map(column => column.map(row => row.length));\n}\nfunction handleControlKeyDown({\n  controlsRef,\n  levelIndex,\n  rowIndex,\n  cellIndex,\n  event\n}) {\n  const direction = getDirection(event.key);\n  if (direction) {\n    event.preventDefault();\n    const size = getControlsSize(controlsRef);\n    focusOnNextFocusableControl({\n      controlsRef,\n      direction,\n      levelIndex,\n      rowIndex,\n      cellIndex,\n      size\n    });\n  }\n}\nexport { handleControlKeyDown };","map":{"version":3,"names":["getNextIndex","direction","levelIndex","rowIndex","cellIndex","size","length","focusOnNextFocusableControl","controlsRef","_a","_b","nextIndex","controlToFocus","current","disabled","getAttribute","focus","getDirection","key","getControlsSize","map","column","row","handleControlKeyDown","event","preventDefault"],"sources":["/home/khushbu/workspace/scrum-master-v2/node_modules/@mantine/dates/src/utils/handle-control-key-down.ts"],"sourcesContent":["import { RefObject } from 'react';\n\ntype ControlsRef = RefObject<HTMLButtonElement[][][]>;\ntype Direction = 'up' | 'down' | 'left' | 'right';\n\ntype NextIndexInput = Omit<ShiftFocusInput, 'controlsRef'>;\n\nfunction getNextIndex({ direction, levelIndex, rowIndex, cellIndex, size }: NextIndexInput) {\n  switch (direction) {\n    case 'up':\n      if (levelIndex === 0 && rowIndex === 0) {\n        return null;\n      }\n      if (rowIndex === 0) {\n        return {\n          levelIndex: levelIndex - 1,\n          rowIndex:\n            cellIndex <= size[levelIndex - 1][size[levelIndex - 1].length - 1] - 1\n              ? size[levelIndex - 1].length - 1\n              : size[levelIndex - 1].length - 2,\n          cellIndex,\n        };\n      }\n      return {\n        levelIndex,\n        rowIndex: rowIndex - 1,\n        cellIndex,\n      };\n\n    case 'down':\n      if (rowIndex === size[levelIndex].length - 1) {\n        return {\n          levelIndex: levelIndex + 1,\n          rowIndex: 0,\n          cellIndex,\n        };\n      }\n      if (\n        rowIndex === size[levelIndex].length - 2 &&\n        cellIndex >= size[levelIndex][size[levelIndex].length - 1]\n      ) {\n        return {\n          levelIndex: levelIndex + 1,\n          rowIndex: 0,\n          cellIndex,\n        };\n      }\n      return {\n        levelIndex,\n        rowIndex: rowIndex + 1,\n        cellIndex,\n      };\n\n    case 'left':\n      if (levelIndex === 0 && rowIndex === 0 && cellIndex === 0) {\n        return null;\n      }\n      if (rowIndex === 0 && cellIndex === 0) {\n        return {\n          levelIndex: levelIndex - 1,\n          rowIndex: size[levelIndex - 1].length - 1,\n          cellIndex: size[levelIndex - 1][size[levelIndex - 1].length - 1] - 1,\n        };\n      }\n      if (cellIndex === 0) {\n        return {\n          levelIndex,\n          rowIndex: rowIndex - 1,\n          cellIndex: size[levelIndex][rowIndex - 1] - 1,\n        };\n      }\n      return {\n        levelIndex,\n        rowIndex,\n        cellIndex: cellIndex - 1,\n      };\n\n    case 'right':\n      if (\n        rowIndex === size[levelIndex].length - 1 &&\n        cellIndex === size[levelIndex][rowIndex] - 1\n      ) {\n        return {\n          levelIndex: levelIndex + 1,\n          rowIndex: 0,\n          cellIndex: 0,\n        };\n      }\n      if (cellIndex === size[levelIndex][rowIndex] - 1) {\n        return {\n          levelIndex,\n          rowIndex: rowIndex + 1,\n          cellIndex: 0,\n        };\n      }\n      return {\n        levelIndex,\n        rowIndex,\n        cellIndex: cellIndex + 1,\n      };\n\n    default:\n      return { levelIndex, rowIndex, cellIndex };\n  }\n}\n\ninterface ShiftFocusInput {\n  controlsRef: ControlsRef;\n  direction: Direction;\n  levelIndex: number;\n  rowIndex: number;\n  cellIndex: number;\n  size: number[][];\n}\n\nfunction focusOnNextFocusableControl({\n  controlsRef,\n  direction,\n  levelIndex,\n  rowIndex,\n  cellIndex,\n  size,\n}: ShiftFocusInput) {\n  const nextIndex = getNextIndex({ direction, size, rowIndex, cellIndex, levelIndex });\n\n  if (!nextIndex) {\n    return;\n  }\n\n  const controlToFocus =\n    controlsRef.current[nextIndex.levelIndex]?.[nextIndex.rowIndex]?.[nextIndex.cellIndex];\n\n  if (!controlToFocus) {\n    return;\n  }\n\n  if (\n    controlToFocus.disabled ||\n    controlToFocus.getAttribute('data-hidden') ||\n    controlToFocus.getAttribute('data-outside')\n  ) {\n    focusOnNextFocusableControl({\n      controlsRef,\n      direction,\n      levelIndex: nextIndex.levelIndex,\n      cellIndex: nextIndex.cellIndex,\n      rowIndex: nextIndex.rowIndex,\n      size,\n    });\n  } else {\n    controlToFocus.focus();\n  }\n}\n\nfunction getDirection(key: KeyboardEvent['key']): Direction {\n  switch (key) {\n    case 'ArrowDown':\n      return 'down';\n    case 'ArrowUp':\n      return 'up';\n    case 'ArrowRight':\n      return 'right';\n    case 'ArrowLeft':\n      return 'left';\n    default:\n      return null;\n  }\n}\n\nfunction getControlsSize(controlsRef: ControlsRef) {\n  return controlsRef.current.map((column) => column.map((row) => row.length));\n}\n\ninterface HandleControlKeyDownInput {\n  controlsRef: ControlsRef;\n  levelIndex: number;\n  rowIndex: number;\n  cellIndex: number;\n  event: React.KeyboardEvent<HTMLButtonElement>;\n}\n\nexport function handleControlKeyDown({\n  controlsRef,\n  levelIndex,\n  rowIndex,\n  cellIndex,\n  event,\n}: HandleControlKeyDownInput) {\n  const direction = getDirection(event.key);\n\n  if (direction) {\n    event.preventDefault();\n\n    const size = getControlsSize(controlsRef);\n\n    focusOnNextFocusableControl({\n      controlsRef,\n      direction,\n      levelIndex,\n      rowIndex,\n      cellIndex,\n      size,\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}